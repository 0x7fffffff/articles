---
layout: post
title: NSLocale

ref: "https://developer.apple.com/library/mac/#documentation/Cocoa/Reference/Foundation/Classes/NSLocale_Class/Reference/Reference.html"
framework: Foundation
rating: 9.0
published: true
translator: "Henry Lee"
description: "产品的国际化就像牙线：所有人都知道他们应该使用，却可能没有去做。"
---

Internationalization is like flossing: everyone knows they should do it, but probably don't. 
产品的国际化就像牙线：所有人都知道他们应该使用，却可能没有去做

And like any habit, it becomes second-nature with practice, to the point that you couldn't imagine _not_ doing it. All it takes is for someone to show you the way. 

就想其他的一些习惯一样，国际化也需要练习到你不敢想象你_不去做_做，它才会成为你的第二本性。

Let NSHipster be your dental hygienist Virgil through these foreign lands.. without all of the lecturing about tooth decay (promsies!)

就让NSHipster成为你的维吉尔牙齿健康专家帮你通过这一片异土，保证没有蛀牙哟！

## i18n versus l10n

## i18n相对于l10n

As is necessary in any discussion about Internationalization (i18n) or Localization (l10n), we must take some time to differentiate the two:

每当我们讨论国际化（i18n）或者本地化（l10n）的时候，我们有必要也必须弄清楚两者之间的区别：

- **Localization** is the process of adapting your application for a specific market, or _locale_.
- **Internationalization** is the process of preparing your app to be localized. 

- **本地化**是将你的应用适应某一个特定市场的操作。
- **国际化**是准备将你的应用本地化的一个过程。 

> Internationalization is a necessary, but not sufficient condition for localization, and will be the focus of this article. Localization, which involves the translation of text and assets into a particular language, will be covered in a future edition of NSHipster.

> 国际化是必要的，但不是本地化的充分条件，它也是这篇文章主要讨论的东西。本地化，包括将一些文本和资源翻译成指定语言的套作，将会在NSHipster之后的内容中涉及到。

What makes internationalization difficult is having to think outside of your cultural context. All of the assumptions you have about the way things are supposed to work must be acknowledged and reconsidered. You have to fight the urge to write off things that may seem trivial, like sorting and collation, and empathize with the pain and confusion even minor differences may cause.

像排序或者分类之类的工作，之前你觉得很微不足道而不想去管，现在你必须得与这种情绪做斗争了，而且还得重视一些极小差别可能带来的痛苦或者困惑。

Fortunately for us, we don't have to do this alone. Meet `NSLocale`:

不过幸运的是，我们不是一个人在战斗，现在来介绍`NSLocale`:

## `NSLocale`

## `NSLocale`

`NSLocale` is a Foundation class that encapsulates all of the conventions about language and culture for a particular locale. A locale encompasses all of the linguistic and cultural norms of a particular group of people, including:

`NSLocale`是一个包含这所有地区的语言与文化习俗的基础类。一个`NSLocale`的实例包含了针对特定一群人的所有语言文化基准，包括：

- Language
- Keyboards
- Number, Date, and Time Formats
- Currency
- Collation and Sorting
- Use of Symbols, Colors, and Iconography

- 语言
- 键盘 
- 数字、日期和时间格式
- 货币
- 排序和分类
- 符号、颜色与头像的使用


Each locale corresponds to a _locale identifier_, such as `en_US`, `fr_FR`, `ja_JP`, and `en_GB`, which include a language code (e.g. `en` for English) and a region code (e.g. `US` for United States). 

每一个`NSLocale`实例对应着一个_地区标识符_，例如`en_US`，`fr_FR`，`ja_JP`和`en_GB`，这些标识符包含一个语言码（例如`en`代表英语）和一个地区码（例如`US`代表美国）。

Locale identifiers can encode more explicit preferences about currency, calendar system, or number formats, such as in the case of `de_DE@collation=phonebook,currency=DDM`, which specifies German spoken in Germany, using [phonebook collation](http://developer.mimer.com/charts/german_phonebook.htm), and using the pre-Euro [Deutsche Mark](http://en.wikipedia.org/wiki/Deutsche_Mark).

地区标识符还能标识更多更详尽的货币、日历系统或者数字表示的一些使用喜好，例如`de_DE@collation=phonebook,currency=DDM`表示了说德语的德国人，用着[电话本排序](http://developer.mimer.com/charts/german_phonebook.htm)，使用的货币在加入欧盟之前是德国马克。

Users can change their locale settings in the "Language & Text" (or "International" on older versions of OS X) System Preferences on the Mac, or "General > International" in iOS Settings.

用户可以在“文字和语音”（在早期版本的OS X里是“国际化”）选项里改变他们的系统设置，在iOS里是在“通用>多语言环境”里设置。

![Language & Text System Preferences](http://nshipster.s3.amazonaws.com/nslocale-international-system-preferences.png)

## Formatting Dates & Numbers
## 日期格式和数字

Although `NSLocale` encapsulates a rich set of domain-specific information, its typical usage is rather understated.

尽管`NSLocale`包含了大量的不同区域的信息，但它的传统用法还是很保守的。

If there's just one thing you should learn about `NSLocale`, it's that you should always pass `[NSLocale currentLocale]` into your `NSDateFormatter` and `NSNumberFormatter` instances. Doing this will ensure that dates, numbers, and currencies will be formatted according to the localization preferences of the user.

如果你要从`NSLocale`里学一样东西，那就是你总是需要把`[NSLocale currentLocale]`传进`NSDateFormatter`和`NSNumberFormatter`的实例，这样做能确保日期、数字和货币能根据用户设置的地点信息显示正确的格式。

Actually, make that a meta lesson about locales: always use `NSDateFormatter` and `NSNumberFormatter` when displaying anything to do with dates or numbers, respectively.

实际上，当你需要展示任何有关日期或者数字的时候永远分别用到`NSDateFormatter`或者`NSNumberFormatter`将应该是一个最基本的知识。

But let's get back to some of the cool features of `NSLocale` itself, shall we?

不过还是让我们来看看`NSLocale`一些更棒的内容吧。

## `-objectForKey:`
## `-objectForKey:`

`NSLocale` typifies Foundation's obsession with domain-specific pedantry, and nowhere is this more visible than in `-objectForKey:`. Cue the list of available constants:

`NSLocale` typifies Foundation's obsession with domain-specific pedantry, and nowhere is this more visible than in `-objectForKey:`. Cue the list of available constants:

- `NSLocaleIdentifier`
- `NSLocaleLanguageCode`
- `NSLocaleCountryCode`
- `NSLocaleScriptCode`
- `NSLocaleVariantCode`
- `NSLocaleExemplarCharacterSet`
- `NSLocaleCalendar`
- `NSLocaleCollationIdentifier`
- `NSLocaleUsesMetricSystem`
- `NSLocaleMeasurementSystem`
- `NSLocaleDecimalSeparator`
- `NSLocaleGroupingSeparator`
- `NSLocaleCurrencySymbol`
- `NSLocaleCurrencyCode`
- `NSLocaleCollatorIdentifier`
- `NSLocaleQuotationBeginDelimiterKey`
- `NSLocaleQuotationEndDelimiterKey`
- `NSLocaleAlternateQuotationBeginDelimiterKey`
- `NSLocaleAlternateQuotationEndDelimiterKey`

While this all may seem like fairly esoteric stuff, you may be surprised by the number of opportunities your application has to use this information to make for a better user experience. 

It's the small things, like knowing that quotation marks vary between locales:

> English: “I can eat glass, it doesn't harm me.”  
> German: „Ich kann Glas essen, das tut mir nicht weh.“  
> Japanese:「私はガラスを食べられます。それは私を傷つけません。」  

So if you were building a component that added quotations around arbitrary text, you should use `NSLocaleQuotationBeginDelimiterKey` and `NSLocaleAlternateQuotationEndDelimiterKey` rather than assuming `@"\""` for English quotation marks.

## `-displayNameForKey:value:`

Another impressive, albeit mostly-useless method is `-displayNameForKey:value:`, which can return the display name of a locale identifier (`NSLocaleIdentifier`):

~~~{objective-c}
NSLocale *frLocale = [[NSLocale alloc] initWithLocaleIdentifier:@"fr_FR"];
NSLog(@"fr_FR: %@", [frLocale displayNameForKey:NSLocaleIdentifier value:@"fr_FR"]);
NSLog(@"en_US: %@", [frLocale displayNameForKey:NSLocaleIdentifier value:@"en_US"]);
~~~

> fr_FR: français (France)  
> en_US: anglais (États-Unis)

You should use this method any time you need to display information about the user's current locale, or any alternative locales available to them, like in this screen from the Settings app:

![Languages Settings](http://nshipster.s3.amazonaws.com/nslocale-languages-settings.png)

## `+preferredLanguages`

One final method worth mentioning is `NSLocale +preferredLanguages`, which returns an array of [IETF BCP 47 language identifier](http://tools.ietf.org/html/bcp47) strings, in order of user preference.

An app that communicates with a web server can use these values to define the `Accept-Language` HTTP header, such that the server has the option to return localized resources:

~~~{objective-c}
NSMutableURLRequest *request = ...;
[request setValue:[NSString stringWithFormat:@"%@", [[NSLocale preferredLanguages] componentsJoinedByString:@", "]], forHTTPHeaderField:@"Accept-Language"];
~~~

Even if your server doesn't yet localize its resources, putting this in place now will allow you to flip the switch when the time comes, without having to push an update to the client. Neat!

---

Internationalization is often considered to be an un-sexy topic in programming--just another chore that most projects don't have to worry about. In actuality, designing software for other locales is a valuable exercise (and not just for the economic benefits of expanding your software into other markets). 

One of the greatest joys and challenges in programming is in designing systems that can withstand change. The only way designs can survive this level of change is to identify and refactor assumptions about the system that may not always hold. In this way, internationalization represents the greatest challenge, making us question everything about our cultural identity. And in doing so, we become not just better programmers, but better people, too.

So go and be a better person: make `NSLocale` part of your daily ritual.
