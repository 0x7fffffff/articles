---
layout: post
title: NSValue
author: Mattt Thompson
translator: Ricky Tan
category: Cocoa
tags: nshipster
excerpt: "包装就是用一个面向对象的容器来封装标量及其他一些类型值的过程，主要用于将那些值保存到面向对象的集合中——如数组和字典。在基础类库中，以轻量级著称的一个包装便是 NSValue 。"
---

作为在电影 [eponymous 2012 biopic](http://www.imdb.com/title/tt0443272/) 中出演亚伯拉罕·林肯的一部分，丹尼尔·戴 - 刘易斯坚决要求每次进出剧组时要通过一个标有“时间机器”字样的冷库箱子。<del markdown="1">[真实的故事](http://filmdrunk.uproxx.com/2012/10/daniel-day-lewis-method-acting-lincoln-ny-times-profile)</del>.

当戴 - 刘易斯先生要进行方法演技时那当然会不择手段，人们对用一个神奇的硬纸板箱联结了现代世界和历史世界这件荒唐的事无不感到惊讶。 

然而，为作一个 Objective-C 的程序员，这 _正好_ 是我们正在做的。

……好吧，不是 _正好_ ，但是也涉及到一个箱子。

就像在 NSHipster 中 [一而再](http://nshipster.cn/ns_enum-ns_options/) [再而三](http://nshipster.cn/nil/) 地提到的那样，是什么让 Objective-C 保持如此的好奇心？正是将过时的，面向过程的 C 的世界与受 Smalltalk 影响的现代的面向对象的世界兼并的方法。如果能恰到好处地兼并，两个世界的对立关系就可以被用来熟练地开发语义上丰富的软件，而不牺牲性能。但是在新与旧的鸿沟之间架桥的却是乌烟瘴气的强制类型转换、无缝转换和包装。

包装就是用面向对象的容器来封装标量（`int`，`double`，`BOOL` 等）和值类型（`struct`，`enum`）的过程，主要用于将那些值保存到面向对象的集合中——如数组和字典。

`NSNumber` 常用于包装标量，但是在基础类库中，轻量级的包装冠军是 `NSValue`。

---

`NSValue` 是用于承载单一的 C 或 Objective-C 数据值的容器。它能承载标量和值类型，也能用于指针和对象 ID。

While boxing is an admittedly dry subject matter, there are two methods in particular that are worth noting: `+valueWithBytes:objCType:`, which serves as a primer for working with `NSValue`, and
`+valueWithNonretainedObject:`, which is surprisingly useful for being relatively unknown.

## `valueWithBytes:objCType:`

> `+valueWithBytes:objCType:`
> Creates and returns an NSValue object that contains a given value, which is interpreted as being of a given Objective-C type.
>
> - `value`: The value for the new `NSValue` object.
> - `type`: The Objective-C type of value. `type` should be created with the Objective-C `@encode()` compiler directive; it should not be hard-coded as a C string.

`@encode` was discussed in [our rundown of the myriad `@` Compiler Directives](http://nshipster.com/at-compiler-directives/):

> `@encode()`: Returns the [type encoding](http://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html) of a type. This type value can be used as the first argument encode in `NSCoder -encodeValueOfObjCType:at`.

The subject of type encodings would make for [a great article of its own](http://nshipster.com/type-encodings/), but the main takeaway is that it serves as a terse, human-readable representation of the structure of a type. For example,

~~~{objective-c}
typedef struct example {
  id   anObject;
  char *aString;
  int  anInt;
} Example;
~~~

...has the encoding:

~~~{objective-c}
{example=@*i}
~~~

`NSValue` uses this type encoding to create the necessary data structures to represent these values internally. Neat!

## `valueWithNonretainedObject:`

> `+valueWithNonretainedObject:`
> Creates and returns an NSValue object that contains a given object.
>
> `anObject`: The value for the new object.

If you already knew about `valueWithNonretainedObject`, you should be nodding with a knowing grin. If you didn't, you're likely staring incredulously with mouth agape. Or if not, you will be soon.

In short, `valueWithNonretainedObject:` allows objects to be added to a collection, without the need for satisfying `<NSCopying>`.

It's something that comes up occasionally, working with objects that can't be directly added to an `NSArray` or `NSDictionary`. Without knowing about `valueWithNonretainedObject:`, this would be something that would throw off your entire game—especially if you're just starting out in Objective-C.

But now you're in the know. You won't be stifled by such pedestrian concerns. You need not grope around for answers with [`NSPointerArray`](https://developer.apple.com/library/mac/#documentation/Cocoa/Reference/Foundation/Classes/NSPointerArray_Class/Introduction/Introduction.html) or [`NSMapTable`](https://developer.apple.com/library/mac/#documentation/Cocoa/Reference/NSMapTable_class/Reference/NSMapTable.html#//apple_ref/occ/cl/NSMapTable). Today is a new day.

---

Having unpacked all of this wisdom about `NSValue`, you can now face that cruel divide between procedural and object-oriented; C and Smalltalk. Because everything is easy with a magic box.
