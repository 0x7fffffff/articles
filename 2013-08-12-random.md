---
title: rand(3) / random(3) / arc4random(3) / et al.
author: Mattt Thompson
category: Objective-C
excerpt: "What passes for randomness is merely a hidden chain of causality. Of course, app developers could care less about philosophy—what they want is code. Thus, our goal this week: to clear up all of the lingering questions and misunderstandings about doing random things in Objective-C"
translator: April Peng
excerpt: "所谓的随机性只是潜在的因果关系。当然，应用程序开发人员可以不关心哲学，他们关心的是代码。因此，我们本周的目标：清理所有长期以来在 Objective-C 中与随机有关的问题和误解"
---

What passes for randomness is merely a hidden chain of causality.

所谓的随机性只是潜在的因果关系。

In a mechanical universe of material interactions expressed through mathematical equations, it is unclear whether nature encodes an element of chance, or if it's a uniquely human way to reconcile uncertainty.

在通过数学公式表示物质相互作用的机械宇宙里，目前还不清楚是否自然也会随机的给元素编码，或者或许它是人类独有的方式来调和不确定性。

We can be sure of one thing, however: in the closed, digital universe of CPU cycles, processes, and threads, there is no true randomness, only _pseudorandomness_.

然而我们可以肯定一件事：在 CPU 周期，进程和线程这样封闭的数字宇宙中，没有真正的随机性，只有 _伪随机性（pseudorandomness）_。

Pseudorandomness, is often implemented in a way very similar to a [cryptographic hash](https://zh.wikipedia.org/wiki/%E5%AF%86%E7%A2%BC%E9%9B%9C%E6%B9%8A%E5%87%BD%E6%95%B8), as a deterministic function that returns a value based on the current time (salted, of course, by some initial seed value). Also like hash functions, there are a number of <acronym>PRNG</acronym>, or pseudorandom number generators, each of which are optimized for particular performance characteristics: uniformity, periodicity, and computational complexity.

伪随机性，通常以非常类似于[加密散列](http://en.wikipedia.org/wiki/Cryptographic_hash_function)的方式被实现，基于当前时间返回值作为确定性函数（当然通过一些初始种子值经过加密）。就像哈希函数，也有许多 PRNG，或者伪随机数生成器，其中每一个为了特定的性能特性被优化：均匀性，周期性，以及计算复杂度。

Of course, for app developers, all of this is an academic exercise. And rather than bore you with any more high-minded, long-winded treatises on the philosophical nature of randomness, we're going to tackle this one FAQ-style.

当然，对于应用程序开发人员，这一切只是一个学术活动。这不是一篇为了宣讲随机性的哲学性质的更高尚的，啰嗦的论文，我们用 FAQ 的风格来解决这个问题。

Our goal this week: to clear up all of the lingering questions and misunderstandings about doing random things in Objective-C. Let's dive in!

我们本周的目标：清理所有长期以来在 Objective-C 中与随机有关的问题和误解。好了，让我们来看看吧！

---

## How Do I Generate a Random Number in Objective-C?

## 如何生成一个 Objective-C 的随机数？

_tl;dr_: **Use `arc4random()` and its related functions.**

_tl;dr_: **使用 `arc4random()` 及其相关功能**。

Specifically, to generate a random number between `0` and `N - 1`, use `arc4random_uniform()`, which avoids [modulo bias](http://eternallyconfuzzled.com/arts/jsw_art_rand.aspx).

具体而言，产生一个 `0` 和 `N - 1` 之间的随机数，使用 `arc4random_uniform()`，从而避免[模偏差(modulo bias)](http://eternallyconfuzzled.com/arts/jsw_art_rand.aspx)。

### Random `int` between `0` and `N - 1`

### `0` 到 `N - 1` 之间的随机整数

~~~{objective-c}
NSUInteger r = arc4random_uniform(N);
~~~

### Random `int` between `1` and `N`

### `0` 到 `N` 之间的随机整数

~~~{objective-c}
NSUInteger r = arc4random_uniform(N) + 1;
~~~

### Random `double` between `0` and `1`

### `0` 到 `1` 之间的随机浮点数（double）

If you are generating a random `double` or `float`, another good option is the more obscure `rand48` family of functions, including `drand48(3)`.

如果你要生成一个随机 `double` 或 `float`，另一个很好的选择是功能较模糊的 `rand48` 家族，包括 `drand48(3)`。

~~~{objective-c}
srand48(time(0));
double r = drand48();
~~~

> `rand48` functions, unlike `arc4random` functions, require an initial value to be seeded before generating random numbers. This seed function, `srand48(3)`, should only be run once.

> 不像 `arc4random` 方法， `rand48` 方法在产生随机数之前需要种子的初始值。这个种子功能，`srand48(3)`，应该只运行一次。

## How Do I Pick a Random Element from an `NSArray`?

## 我如何从一个 `NSArray` 选择一个随机元素？

Use `arc4random_uniform(3)` to generate a random number in the range of a non-empty array.

使用 `arc4random_uniform(3)` 产生一个在非空数组范围内的随机数。

~~~{objective-c}
if ([array count] > 0) {
  id obj = array[arc4random_uniform([array count])];
}
~~~

## How Do I Randomly Order an `NSArray`?

## 我如何随机排序一个 `NSArray`？

~~~{objective-c}
NSMutableArray *mutableArray = [NSMutableArray arrayWithArray:array];
NSUInteger count = [mutableArray count];
// See http://en.wikipedia.org/wiki/Fisher–Yates_shuffle
if (count > 1) {
  for (NSUInteger i = count - 1; i > 0; --i) {
      [mutableArray exchangeObjectAtIndex:i withObjectAtIndex:arc4random_uniform((int32_t)(i + 1))];
  }
}

NSArray *randomArray = [NSArray arrayWithArray:mutableArray];
~~~

> This code is borrowed from [TTTRandomizedEnumerator](https://github.com/mattt/TTTRandomizedEnumerator), which also provides randomized enumerators for `NSSet`, `NSOrderedSet`, and `NSDictionary`.

> 此代码是从 [TTTRandomizedEnumerator](https://github.com/mattt/TTTRandomizedEnumerator) 借过来的，它也为 `NSSet`，`NSOrderedSet`，和 `NSDictionary` 提供了随机枚举。

## How Do I Generate a Random String?

## 我如何生成一个随机字符串？

If you're looking to generate "[lorem ipsum](http://en.wikipedia.org/wiki/Lorem_ipsum)"-style sentences, try constructing a [Markov Chain](http://en.wikipedia.org/wiki/Markov_chain) from a [corpus](http://en.wikipedia.org/wiki/Text_corpus).

如果你正在寻找生成 “[lorem ipsum](http://en.wikipedia.org/wiki/Lorem_ipsum)” 式的句子，尝试从 [corpus](http://en.wikipedia.org/wiki/Text_corpus) 构建一个 [Markov Chain](http://en.wikipedia.org/wiki/Markov_chain)。

Otherwise, if you're looking to just get random letters, try one of the following methods:

或者，如果你正在寻找只是得到随机字母的方法，请尝试以下方法之一：

### Generate a Random Lowercase `NSString`

### 生成一个随机的小写 `NSString`

If you are operating on a known, contiguous range of Unicode characters, such as the lowercase letters (`U+0061` — `U+007A`), you can do a simple conversion from a `char`:

如果你是对一个已知的，连续范围的 Unicode 字符做处理，例如小写字母 (`U+0061` — `U+007A`)，你可以从 `char` 做一个简单的换算：

~~~{objective-c}
NSString *letter = [NSString stringWithFormat:@"%c", arc4random_uniform(26) + 'a'];
~~~

### Pick a Random Character From an `NSString`

### 从一个 `NSString` 选择一个随机字符

Otherwise, a simple way to pick random letters from a set of your choosing is to simply create a string containing all of the possible letters:

另外，从一组你选择的字符中来挑选随机字母的一个简单的方法是简单地创建一个包含所有可能的字母的字符串：

~~~{objective-c}
NSString *vowels = @"aeiouy";
NSString *letter = [vowels substringWithRange:NSMakeRange(arc4random_uniform([vowels length]), 1)];
~~~

## Why Should I Use `arc4random(3)` instead of `rand(3)` or `random(3)`?

## 为什么要使用 `arc4random(3)`，而不是 `rand(3)` 或 `random(3)`？

> C functions are typically denoted with a number `3` inside of parentheses, following the organizational convention of [`man` pages](http://en.wikipedia.org/wiki/Man_page#Manual_sections).

> C 函数通常表示为多个带括号的 `3`，请遵从以下组织公约 [`man` pages](http://en.wikipedia.org/wiki/Man_page#Manual_sections)。

- `arc4random` does not require an initial seed (with `srand` or `srandom`), making it that much easier to use.
- `arc4random` has a range up to `0x100000000 (4294967296)`, whereas `rand` and `random` top out at `RAND_MAX = 0x7fffffff (2147483647)`.
- `rand` has often been implemented in a way that regularly cycles low bits, making it more predictable.

- `arc4random` 不需要初始种子（用 `srand` 或 `srandom`），使它更加容易使用。
- `arc4random` 范围可达 `0x100000000 (4294967296)`，而 `rand` 和 `random` 的上限在 `RAND_MAX = 0x7fffffff (2147483647)`。
- `rand` 经常定期被周期低位的方式，使其更可预测执行。

## What are `rand(3)`, `random(3)`, and `arc4random(3)`, and Where Do They Come From?

## 什么是 `rand(3)`, `random(3)`, 和 `arc4random(3)`，以及它们从哪里来的？

- `rand` is a standard C function.
- `random` is [defined as part of the POSIX standard](http://pubs.opengroup.org/onlinepubs/009695399/functions/initstate.html).
- `arc4random` is provided on BSD and derived platforms.

- `rand` 是一个标准的 C 函数。
- `random` 是[定义为 POSIX 标准的一部分](http://pubs.opengroup.org/onlinepubs/009695399/functions/initstate.html)。
- `arc4random` 是在 BSD 和派生平台。

---

If you have any additional questions about randomness on Objective-C, feel free to tweet [@NSHipster](https://twitter.com/NSHipster). As always, corrections are welcome in the form of a [pull request](https://github.com/NSHipster/articles/pulls).

如果你有关于 Objective-C 随机性的其他任何问题，请随时 tweet [@NSHipster](https://twitter.com/NSHipster)。与往常一样，欢迎以 [pull request](https://github.com/NSHipster/articles/pulls) 的形式提交更正。
